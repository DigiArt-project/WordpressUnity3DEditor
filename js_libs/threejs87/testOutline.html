<!DOCTYPE html>
<html lang="en">
<head>
    <title>three.js webgl - post processing - Outline Pass</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>

        body {
            background-color: #ffffff;
            margin: 0px;
            overflow: hidden;
            font-family:Monospace;
            font-size:13px;
            text-align:center;
            font-weight: bold;
        }

    </style>
</head>
<body>
<script src="three.js"></script>
<script src="OrbitControls.js"></script>

<script src="CopyShader.js"></script>
<script src="FXAAShader.js"></script>
<script src="EffectComposer.js"></script>
<script src="RenderPass.js"></script>
<script src="ShaderPass.js"></script>
<script src="OutlinePass.js"></script>
<script src="stats.min.js"></script>
<script src='dat.gui.js'></script>

<script>

    var container, stats;
    var camera, scene, renderer, controls;
    var raycaster = new THREE.Raycaster();
    var mouse = new THREE.Vector2();
    var selectedObjects = [];
    var composer, effectFXAA, outlinePass;

    var group = new THREE.Object3D();
    var params = {
        edgeStrength: 3.0,
        edgeGlow: 0.0,
        edgeThickness: 1.0,
        pulsePeriod: 0,
        rotate: false,
        usePatternTexture: false
    };
    // Init gui
    var gui = new dat.GUI();
    gui.add(params, "edgeStrength", 0.01, 10).onChange(function( value ) {
        outlinePass.edgeStrength = Number(value);
    });
    gui.add(params, "edgeGlow", 0.0, 1).onChange(function( value ) {
        outlinePass.edgeGlow = Number(value);
    });
    gui.add(params, "edgeThickness", 1, 4).onChange(function( value ) {
        outlinePass.edgeThickness = Number(value);
    });
    gui.add(params, "pulsePeriod", 0.0, 5).onChange(function( value ) {
        outlinePass.pulsePeriod = Number(value);
    });
    gui.add(params, "rotate");
    gui.add(params, "usePatternTexture").onChange(function( value ) {
        outlinePass.usePatternTexture = value;
    });
    var Configuration = function() {
        this.visibleEdgeColor = "#ffffff";
        this.hiddenEdgeColor  = "#190a05";
    };
    var conf = new Configuration();
    var controladorVisible = gui.addColor( conf, 'visibleEdgeColor');
    var controladorHidden = gui.addColor( conf, 'hiddenEdgeColor');
    controladorVisible.onChange(function( colorValue ) {
        //the return value by the chooser is like as: #ffff
        colorValue = colorValue.replace('#', '');
        function hexToRgb( hex ) {
            var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[ 1 ], 16),
                g: parseInt(result[ 2 ], 16),
                b: parseInt(result[ 3 ], 16)
            } : null;
        }
        var rgba  = hexToRgb(colorValue);
        var color = outlinePass.visibleEdgeColor;
        color.r   = rgba.r / 255;
        color.g   = rgba.g / 255;
        color.b   = rgba.b / 255;
    });
    controladorHidden.onChange(function( colorValue ) {
        //the return value by the chooser is like as: #ffff
        colorValue = colorValue.replace('#', '');
        function hexToRgb( hex ) {
            var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[ 1 ], 16),
                g: parseInt(result[ 2 ], 16),
                b: parseInt(result[ 3 ], 16)
            } : null;
        }
        var rgba  = hexToRgb(colorValue);
        var color = outlinePass.hiddenEdgeColor;
        color.r   = rgba.r / 255;
        color.g   = rgba.g / 255;
        color.b   = rgba.b / 255;
    });
    init();
    animate();
    function init() {
        container = document.createElement( 'div' );
        document.body.appendChild( container );
        var width = window.innerWidth || 1;
        var height = window.innerHeight || 1;
        var devicePixelRatio = window.devicePixelRatio || 1;
        renderer = new THREE.WebGLRenderer( { antialias: false } );
        renderer.shadowMap.enabled = true;
        renderer.setClearColor( 0xa0a0a0 );
        renderer.setPixelRatio( 1 );
        renderer.setSize( width, height );
        document.body.appendChild( renderer.domElement );

        camera = new THREE.PerspectiveCamera( 45, width / height, 0.1, 100 );
        camera.position.z = 8;
        camera.position.x = 0;
        scene = new THREE.Scene();
        var manager = new THREE.LoadingManager();
        manager.onProgress = function ( item, loaded, total ) {
            console.log( item, loaded, total );
        };

        controls = new THREE.OrbitControls( camera, renderer.domElement );
        controls.enableDamping = true;
        controls.dampingFactor = 0.25;
        scene.add( group );
        var light = new THREE.DirectionalLight( 0xddffdd, 0.4);
        light.position.z = 1;
        light.position.y = 1;
        light.position.x = 1;
        scene.add( light );
        light.castShadow = true;
        light.shadow.mapSize.width = 1024;
        light.shadow.mapSize.height = 1024;
        var d = 20;
        light.shadow.camera.left = - d;
        light.shadow.camera.right = d;
        light.shadow.camera.top = d;
        light.shadow.camera.bottom = - d;
        light.shadow.camera.far = 1000;
        var light2 = new THREE.DirectionalLight( 0xaadddd, 0.15 );
        light2.position.z = 1;
        light2.position.x = -1;
        light2.position.y = -1;
        scene.add( light2 );
        var light3 = new THREE.DirectionalLight( 0xddddaa, 0.1 );
        light3.position.z = 1;
        light3.position.x = -1;
        light3.position.y = 1;
        scene.add( light3 );
        var light3 = new THREE.AmbientLight( 0xaaaaaa, 0.2 );
        scene.add( light3 );
        var geometry = new THREE.SphereBufferGeometry( 3, 48, 24 );
        for ( var i = 0; i < 20; i ++ ) {
            var material = new THREE.MeshLambertMaterial();
            material.roughness = 1;//0.5 * Math.random() + 0.25;
            material.metalness = 0;
            material.color.setHSL( Math.random(), 1.0, 0.3 );
            var mesh = new THREE.Mesh( geometry, material );
            mesh.position.x = Math.random() * 4 - 2;
            mesh.position.y = Math.random() * 4 - 2;
            mesh.position.z = Math.random() * 4 - 2;
            mesh.rotation.x = Math.random();
            mesh.rotation.y = Math.random();
            mesh.rotation.z = Math.random();
            mesh.receiveShadow = true;
            mesh.castShadow = true;
            mesh.scale.x = mesh.scale.y = mesh.scale.z = Math.random() * 0.3 + 0.1;
            group.add( mesh );
        }
        var floorMaterial = new THREE.MeshLambertMaterial();
        floorMaterial.side = THREE.DoubleSide;
        material.roughness = 0.5 * Math.random() + 0.25;
        material.metalness = 0;
        var floorGeometry = new THREE.PlaneBufferGeometry( 12, 12 );
        var floorMesh = new THREE.Mesh( floorGeometry, floorMaterial );
        floorMesh.rotation.x -= Math.PI * 0.5;
        floorMesh.position.y -= 1.5;
        group.add( floorMesh );
        floorMesh.receiveShadow = true;
        var geometry = new THREE.TorusGeometry( 1, 0.3, 16, 100 );
        var material = new THREE.MeshPhongMaterial( { color: 0xffaaff } );
        var torus = new THREE.Mesh( geometry, material );
        torus.position.z = -4;
        group.add( torus );
        torus.receiveShadow = true;
        torus.castShadow = true;


        // Add Axes helper
        var axisHelper = new THREE.AxisHelper( 1 );
        axisHelper.position.x = 10;
        scene.add(axisHelper);


        var material = new THREE.LineBasicMaterial({
            color: 0x0000ff
        });

        var geometry = new THREE.Geometry();
        geometry.vertices.push(
            new THREE.Vector3( -10, 0, 0 ),
            new THREE.Vector3( 0, 10, 0 ),
        );

        line = new THREE.Line( geometry, material );
        scene.add( line );


        geometry = new THREE.BoxGeometry(5, 5, 5);
        material = new THREE.MeshBasicMaterial({
            // 0x represents #
            color: 0xFFFFFF,
            wireframe: true
        });

        mesh = new THREE.Mesh(geometry, material);
        scene.add(mesh);


        // postprocessing
        composer = new THREE.EffectComposer( renderer );
        var renderPass = new THREE.RenderPass( scene, camera );
        composer.addPass( renderPass );
        outlinePass = new THREE.OutlinePass( new THREE.Vector2(window.innerWidth, window.innerHeight), scene, camera);
        composer.addPass( outlinePass );
        var onLoad = function ( texture ) {
            outlinePass.patternTexture = texture;
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
        };
        var loader = new THREE.TextureLoader();
        // load a resource
        loader.load(
            // resource URL
            'textures/tri_pattern.jpg',
            // Function when resource is loaded
            onLoad
        );
        effectFXAA = new THREE.ShaderPass(THREE.FXAAShader);
        effectFXAA.uniforms['resolution'].value.set(1 / window.innerWidth, 1 / window.innerHeight );
        effectFXAA.renderToScreen = true;
        composer.addPass( effectFXAA );
        window.addEventListener( 'resize', onWindowResize, false );
        window.addEventListener( 'mousemove', onTouchMove );
        window.addEventListener( 'touchmove', onTouchMove );
        function onTouchMove( event ) {
            var x, y;
            if ( event.changedTouches ) {
                x = event.changedTouches[ 0 ].pageX;
                y = event.changedTouches[ 0 ].pageY;
            } else {
                x = event.clientX;
                y = event.clientY;
            }
            mouse.x = ( x / window.innerWidth ) * 2 - 1;
            mouse.y = - ( y / window.innerHeight ) * 2 + 1;
            checkIntersection();
        }
        function addSelectedObject(object) {
            selectedObjects = [];
            selectedObjects.push(object);
        }
        function checkIntersection() {
            raycaster.setFromCamera( mouse, camera );
            var intersects = raycaster.intersectObjects( [ scene ], true );
            if ( intersects.length > 0 ) {
                var selectedObject = intersects[ 0 ].object;
                addSelectedObject(selectedObject);
                outlinePass.selectedObjects = selectedObjects;
                console.log("//-------//");
                console.log(outlinePass.selectedObjects);
            }
            else {
                 outlinePass.selectedObjects = [];
            }
        }
    }
    function onWindowResize() {
        var width = window.innerWidth || 1;
        var height = window.innerHeight || 1;
        var devicePixelRatio = window.devicePixelRatio || 1;
        camera.aspect = width / height;
        camera.updateProjectionMatrix();
        renderer.setSize( width, height );
        composer.setSize( width, height );
        effectFXAA.uniforms['resolution'].value.set(1 / window.innerWidth, 1 / window.innerHeight );
    }
    function animate() {
        requestAnimationFrame( animate );

        var timer = performance.now();
        if(params.rotate)
            group.rotation.y = timer * 0.0001;
        renderer.autoClear = true;
        renderer.setClearColor( 0xfff0f0 );
        renderer.setClearAlpha( 0.0 );
        composer.render();

    }

</script>
</body>
</html>